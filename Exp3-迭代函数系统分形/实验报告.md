# 迭代函数系统(IFS)分形实验报告

## 实验目的

1. 理解迭代函数系统(IFS)的基本原理和算法
2. 掌握"混沌游戏"随机迭代方法
3. 实现巴恩斯利蕨和概率树的生成
4. 分析不同参数对分形图形的影响

## 实验过程

### 1. 核心算法实现

**IFS参数定义**:
- 巴恩斯利蕨: 4个仿射变换(茎干、小叶片、左右大叶片)
- 概率树: 3个仿射变换(树干、左右分支)

**混沌游戏算法**:
1. 初始化起始点
2. 随机选择变换(按概率)
3. 应用仿射变换生成新点
4. 重复迭代生成点集

### 2. 分形实现

**巴恩斯利蕨参数**:
- 茎干变换: 概率0.01
- 小叶片变换: 概率0.85
- 左右大叶片变换: 各概率0.07

**概率树参数**:
- 树干变换: 概率0.10
- 左右分支变换: 各概率0.45

### 3. 遇到的问题与解决

(请在此描述实现过程中遇到的问题及解决方法)

## 结果展示

### 1. 巴恩斯利蕨
[插入生成的巴恩斯利蕨分形图]
- 展示不同变换对应的叶片部分
- 分析概率参数对叶片密度的影响
![ifs1](https://github.com/user-attachments/assets/d919142a-8003-4935-bba5-b41a6e75c70d)
![ifs2](https://github.com/user-attachments/assets/8c74b3f4-585b-4e5e-99bd-d6db13065ef0)
![ifs5](https://github.com/user-attachments/assets/535ee518-e41e-4ca4-a204-fd5eb405579e)
小叶片概率越大，叶片颜色越实；大叶片概率越大，叶片颜色越淡，叶尖颜色越实。

### 2. 概率树 
[插入生成的概率树分形图]
- 展示分支结构
- 分析变换参数对树形的影响
![ifs3](https://github.com/user-attachments/assets/05071df8-b5b3-4b31-a56d-3fc17bf14a43)
变换参数会使得树形不对称或树干长度有所改变
## 分析与思考

1. **IFS特性分析**
   - 仿射变换参数对图形各部分的影响
   - abcd影响图形的缩放、旋转，ef则是对图形进行平移
   - 概率参数与图形密度的关系
   - 概率越大，密度越大

2. **参数实验**
   - 修改概率参数的效果
   - 修改概率参数会使图形的密度改变，概率越大密度越大，生成的图形叶片孔隙更少
   - 调整变换参数的效果
   - 调整变换参数会改变图形的对称性、角度等特征

3. **扩展思考**
   - 如何设计新的IFS规则生成其他分形
   - 设置新的参数控制图形的缩放、旋转、平移等，从而生成其他分形
   - 添加颜色渐变效果的方法
   - 对不同坐标范围内的点设置不同的颜色
   - 性能优化方案(减少点数同时保持视觉效果)

4. **算法比较**
   - IFS与其他分形生成方法的对比
   - 分形生成方法多样，各有优劣与适用场景。IFS 通过仿射变换迭代生成分形，数学简洁、计算高效，适合经典分形与规则结构，但规则设计复杂、灵活性低；L 系统利用字符串重写模拟生物生长，规则直观，常用于植物建模，不过局限于分枝结构；逃逸时间算法基于复平面迭代计算，能展现无限细节，用于复动力系统分形，却存在计算量大、应用窄的问题；分形噪声通过叠加噪声模拟自然形态，参数灵活，适用于地形纹理生成，并非严格分形；随机分形基于随机过程，可模拟自然现象，结果不可控且计算效率低。​
在选择分形生成方法时，生成严格自相似分形可选 IFS 或逃逸时间算法；模拟自然随机形态用分形噪声或随机分形；生成植物或分枝结构则 L 系统更合适。实际应用中，IFS 常与其他方法结合，以呈现更复杂自然的分形形态 。
   - 随机迭代与确定性迭代的差异
   - 需要数学精确性（如分形维数计算）确定性迭代。确定性迭代：精确控制分形结构，适合数学分析，计算量大（尤其高分辨率时），内存占用高（需存储所有中间点集）。
   - 追求效率或自然随机感（如植物模拟）随机迭代。随机迭代：高效省内存（仅需跟踪单个点），适合复杂分形。初期噪声明显，需足够多的迭代才能收敛到稳定形态。

**注：请在每一部分补充你自己的实验内容、图像、分析和关键代码。**
import numpy as np
import matplotlib.pyplot as plt

def get_fern_params():
    """返回巴恩斯利蕨的IFS参数"""
    # 每个变换包含6个参数(a,b,c,d,e,f)和概率p
    return [
        [0.00, 0.00, 0.00, 0.16, 0.00, 0.00, 0.01],   # 茎干
        [0.85, 0.04, -0.04, 0.85, 0.00, 1.60, 0.85],   # 小叶片
        [0.20, -0.26, 0.23, 0.22, 0.00, 1.60, 0.07],   # 左侧大叶片
        [-0.15, 0.28, 0.26, 0.24, 0.00, 0.44, 0.07]    # 右侧大叶片
    ]

def get_tree_params():
    """返回概率树的IFS参数""" 
    return [
        [0.00, 0.00, 0.00, 0.50, 0.00, 0.00, 0.10],    # 树干
        [0.42, -0.42, 0.42, 0.42, 0.00, 0.20, 0.45],   # 左分支
        [0.42, 0.42, -0.42, 0.42, 0.00, 0.20, 0.45]    # 右分支
    ]

def apply_transform(point, params):
    """应用单个变换到点"""
    x, y = point
    a, b, c, d, e, f, _ = params
    return a*x + b*y + e, c*x + d*y + f

def run_ifs(ifs_params, num_points=100000, num_skip=100):
    """
    运行IFS迭代生成点集
    :param ifs_params: IFS参数列表
    :param num_points: 总点数
    :param num_skip: 跳过前n个点(避免初始不稳定)
    :return: 生成的点坐标数组
    """
    # 提取概率用于随机选择
    probs = [p[-1] for p in ifs_params]
    indices = np.arange(len(ifs_params))
    
    # 初始化
    point = (0.5, 0)  # 初始点
    points = np.zeros((num_points, 2))
    
    # 迭代生成点
    for i in range(num_points + num_skip):
        # 随机选择变换
        idx = np.random.choice(indices, p=probs)
        point = apply_transform(point, ifs_params[idx])
        
        # 跳过初始不稳定点
        if i >= num_skip:
            points[i - num_skip] = point
            
    return points

def plot_ifs(points, title="IFS Fractal", save_path=None):
    """绘制IFS分形并保存为PNG"""
    plt.figure(figsize=(8, 8))
    plt.scatter(points[:,0], points[:,1], s=1, c='green', alpha=0.75)
    plt.title(title)
    plt.axis('equal')
    plt.axis('off')
    plt.show()


if __name__ == "__main__":
    # 生成并绘制巴恩斯利蕨
    fern_params = get_fern_params()
    fern_points = run_ifs(fern_params)
    plot_ifs(fern_points, "Barnsley Fern")
    
    # 生成并绘制概率树
    tree_params = get_tree_params()
    tree_points = run_ifs(tree_params)
    plot_ifs(tree_points, "Probability Tree")
